- Level 11
- The password for the next level is stored in the file data.txt, where all lowercase (a-z) and uppercase (A-Z) letters have been rotated by 13 positions

        the data is encoded with **ROT13** (a simple Caesar cipher shifting letters by 13 positions).
        
    ### Quick solution ###

        You can decode it right in the Bandit shell with:
            tr 'A-Za-z' 'N-ZA-Mn-za-m' < data.txt
        
    ### üîç Explanation ###
        
        - tr = **translate characters**
        - 'A-Za-z' = input character set (all uppercase and lowercase letters)
        - 'N-ZA-Mn-za-m' = output character set, rotated 13 positions
            - A ‚Üí N, B ‚Üí O, ..., N ‚Üí A
            - a ‚Üí n, b ‚Üí o, ..., n ‚Üí a
        
        The `< data.txt` part feeds the file as input to `tr`.
        
        This prints the decoded text directly ‚Äî the **password** will appear in cleartext in the output.
        
     ### 1Ô∏è‚É£ Uppercase alphabet ###
        
    We have A B C D ... Z (26 letters). ROT13 means shift each letter 13 forward, with wrap-around after Z.
        
        - Letters A‚ÄìM shift forward 13 ‚Üí N‚ÄìZ
        - Letters N‚ÄìZ shift forward 13 ‚Üí wrap around to A‚ÄìM
        
        So in tr notation, we write:
        
        A-M ‚Üí N-Z
        N-Z ‚Üí A-M
        
        
        That‚Äôs exactly what 'N-ZA-M' does:
        
        - N-Z ‚Üí maps to the first letters in the output (A-M)
        - A-M ‚Üí maps to the last letters in the output (N-Z)
        
        So `'N-ZA-M'` is **correct**, because `tr` matches each input character to the corresponding output character **by position**.
        
        ---
        
        ### 2Ô∏è‚É£ Lowercase alphabet
        
        Same logic:
        
        - `a‚Äìm` ‚Üí shift 13 ‚Üí `n‚Äìz`
        - `n‚Äìz` ‚Üí shift 13 ‚Üí wrap around ‚Üí `a‚Äìm`
        
        In `tr` notation: `'n-za-m'`.
        
        ---
        
        ### 3Ô∏è‚É£ Why it‚Äôs not `'N-An-A'`
        
        - `tr` expects **two sets of characters of the same length**, mapping one-to-one.
        - `'N-An-A'` would only be 5 letters (`N A n A - ?`) ‚Äî that doesn‚Äôt cover all 26 letters.
        - We need **26 letters for uppercase and 26 letters for lowercase**.
        
        Hence the correct ROT13 `tr` command is:
        
        ```bash
        tr 'A-Za-z' 'N-ZA-Mn-za-m'
        ```
        
        - `'A-Z'` ‚Üí input uppercase
        - `'N-ZA-M'` ‚Üí output uppercase ROT13
        - `'a-z'` ‚Üí input lowercase
        - `'n-za-m'` ‚Üí output lowercase ROT13
        
        ---
        
        ### üß† Optional Python method (if you ever need it)
        
        ```bash
        python3 -c "import codecs; print(codecs.decode(open('data.txt').read(), 'rot_13'))"
        ```
        
- Level 12
    - The password for the next level is stored in the file data.txt, which is a hexdump of a file that has been repeatedly compressed. For this level it may be useful to create a directory under /tmp in which you can work. Use mkdir with a hard to guess directory name. Or better, use the command ‚Äúmktemp -d‚Äù. Then copy the datafile using cp, and rename it using mv (read the manpages!)
        
        ### 1Ô∏è‚É£ Create a temporary working directory
        
        It‚Äôs best to **not work directly in your home directory**, so create a safe temporary folder:
        
        ```bash
        tmpdir=$(mktemp -d)
        cd "$tmpdir"
        ```
        
        - `mktemp -d` ‚Üí creates a directory with a **random, hard-to-guess name**.
        - `tmpdir=$(...)` ‚Üí stores its path in a variable.
        - `cd "$tmpdir"` ‚Üí switch to that directory.
        
        ---
        
        ### 2Ô∏è‚É£ Copy the `data.txt` file
        
        From your Bandit home directory:
        
        ```bash
        cp /home/bandit12/data.txt .
        ```
        
        > Adjust the path if necessary. You now have a local copy in your temporary directory.
        > 
        
        ---
        
        ### 3Ô∏è‚É£ Rename the file
        
        The file is a **hexdump**, so we should rename it to a binary file before processing:
        
        ```bash
        mv data.txt data.bin
        ```
        
        - `mv` ‚Üí renames the file.
        - Now `data.bin` will be our working file.
        
        ---
        
        ### 4Ô∏è‚É£ Convert the hexdump back to binary
        
        Bandit hints that `data.txt` is a **hexdump**, probably generated by `xxd`. To restore the original binary:
        
        ```bash
        xxd -r data.bin > data.orig
        ```
        
        - `xxd -r` ‚Üí reverses a hex dump back into binary.
        - `data.orig` ‚Üí now a binary file (likely a compressed archive).
        
        ---
        
        ### 5Ô∏è‚É£ Decompress repeatedly
        
        Now, the tricky part: the file has been **repeatedly compressed**, often alternating formats like `gzip` and `bzip2`.
        
        You can try decompressing in a loop:
        
        ```bash
        file data.orig
        ```
        
        - This tells you the current file type (gzip, bzip2, tar, etc.).
        
        Then use the appropriate command:
        
        - For gzip:
            
            ```bash
            mv data.orig data.gz
            gunzip data.gz
            ```
            
        - For bzip2:
            
            ```bash
            mv data.orig data.bz2
            bunzip2 data.bz2
            ```
            
        - For tarballs:
            
            ```bash
            tar xf data.tar
            ```
            
        
        > Keep repeating file and the decompress step until file reports a plain text file.
        > 
        
        ---
        
        ### 6Ô∏è‚É£ Read the password
        
        Once the file is finally **plain text**, just:
        
        ```bash
        cat <filename>
        ```
        
        ### TROUBLESHOOTING ISSUES OCCURING DURING THE DECODING:
        
        The problem is that `gunzip` expects the file to have a **`.gz` extension** (or another recognized gzip suffix). Since your file is named `data.out`, `gunzip` refuses to process it unless you tell it explicitly.
        
        Here‚Äôs how to fix it:
        
        ---
        
        ### ‚úÖ Option 1: Rename the file to have a `.gz` suffix
        
        ```bash
        mv data.out data.gz
        gunzip data.gz
        ```
        
        After each decompression:
        
        1. Run `file <filename>` to see the current file type.
        2. Rename if necessary to match the expected suffix for the next decompression tool.
        3. Use the appropriate tool:
        
        | file type | command |
        | --- | --- |
        | gzip | `gunzip <file>` |
        | bzip2 | `bunzip2 <file>` |
        | tar | `tar xf <file>` |
        
        Repeat until `file` says `ASCII text` (or something similar). Then `cat <file>` to get the password.
        
        ### *GZIP MAGIC NUMBER*
        
        ---
        
        Your `data.bin` file is **a hexdump that has already been reversed back into binary**. Looking at the output of `cat data.bin`, it starts with:
        
        ```
        00000000: 1f8b 0808 ...
        ```
        
        - `1f8b` = **gzip magic number** ‚Üí the first layer is a gzip file.
        - After this, the file contains another compressed format inside (`bzip2` etc.) ‚Äî just like in Bandit 12.
        
        Here‚Äôs how to proceed **step by step**:
        
        ---
        
        ### 1Ô∏è‚É£ Rename to `.gz` so `gunzip` can recognize it
        
        ```bash
        mv data.bin data.gz
        ```
        
        ---
        
        ### 2Ô∏è‚É£ Decompress the gzip layer
        
        ```bash
        gunzip data.gz
        ```
        
- Level 13
    - The password for the next level is stored in¬†**/etc/bandit_pass/bandit14 and can only be read by user bandit14**. For this level, you don‚Äôt get the next password, but you get a private SSH key that can be used to log into the next level.¬†**Note:**¬†**localhost**¬†is a hostname that refers to the machine you are working on.
        
        ### ‚úÖ How it‚Äôs intended to work
        
        The Bandit levels that give you a private key (like this one) are **designed to be used from your local machine**, not from inside the Bandit shell.
        
        - You **do not** SSH into localhost from bandit13.
        - You **do not** SCP from inside bandit13.
        
        Instead:
        
        1. On your **local machine** (your own laptop/desktop), copy the private key **from the Bandit server when you first downloaded it from the Bandit webpage**.
        2. Save it locally, for example:
        
        ```bash
        nano /tmp/bandit14_key
        # paste the key
        chmod 600 /tmp/bandit14_key
        ```
        
        1. SSH from your **local machine** to the Bandit server on the **special port (2220)**:
        
        ```bash
        ssh -i /tmp/bandit14_key -p 2220 bandit14@bandit.labs.overthewire.org
        ```
        
        - This will log you in as `bandit14`.
        - Then you can read the password:
        
        ```bash
        cat /etc/bandit_pass/bandit14
        ```
        
- Level 14
    - The password for the next level can be retrieved by submitting the password of the current level to port 30000 on localhost.
        1. Send the password of **bandit14** to port 30000 on localhost:
        
        ```bash
        cat /etc/bandit_pass/bandit14 | nc localhost 30000
        ```
        
        - `cat /etc/bandit_pass/bandit14` ‚Üí reads the **password of the current level**, which is bandit14‚Äôs password.
        - The pipe `|` ‚Üí sends that password **as input** to the next command.
        - `nc localhost 30000` ‚Üí connects to **TCP port 30000 on the local machine** and sends whatever is piped in (`bandit14`‚Äôs password).
        - The server listening on port 30000 receives your password, verifies it, and responds with the **next level‚Äôs password** (bandit15).
        
        ### 2Ô∏è‚É£ Why it works
        
        - Bandit 14‚Äôs level challenge is specifically set up to require **your current level password** to be sent to this service.
        - Only bandit14 can read `/etc/bandit_pass/bandit14` because of Linux file permissions.
        - Port 30000 is a little ‚Äúmini server‚Äù running locally that expects **the current password on stdin** and responds with the next password.
        
        ---
        
        ### 3Ô∏è‚É£ Common mistakes
        
        - Trying to do this **as a different user** (bandit13, bandit15, etc.) ‚Üí fails because you **can‚Äôt read the password file**.
        - Forgetting the pipe ‚Üí `nc` won‚Äôt receive anything to check.
        - Forgetting a newline ‚Üí some services require the password to end with `\n` (though usually `cat` adds it automatically).
- Level 15
    - The password for the next level can be retrieved by submitting the password of the current level to port 30001 on localhost using SSL/TLS encryption.
        
        You need to send the **current password** over an **SSL/TLS** connection to localhost:30001. The usual tool for that is `openssl s_client`. Run this from the account that can read the current password (e.g. `bandit15` if you‚Äôre on level 15).
        
        Two safe, copy-pasteable one-liners:
        
        ```bash
        # variant A: pipe the password into openssl
        printf "%s\n" "$(cat /etc/bandit_pass/bandit15)" | openssl s_client -connect localhost:30001 -quiet 2>/dev/null
        ```
        
        or
        
        ```bash
        # variant B: redirect the password file to openssl
        openssl s_client -connect localhost:30001 -quiet < /etc/bandit_pass/bandit15 2>/dev/null
        ```
        
        ### What each part does
        
        - `cat /etc/bandit_pass/bandit15` (or the `printf` wrapper) : reads your current-level password and ensures a trailing newline.
        - `|` or `<` : sends that password to the TLS client‚Äôs stdin.
        - `openssl s_client -connect localhost:30001` : opens an SSL/TLS connection to localhost port 30001.
        - `quiet` : suppresses some of `s_client`‚Äôs verbose session chatter.
        - `2>/dev/null` : hides remaining diagnostic output (cert info etc.), leaving you with the server response (the next password).
        
        ### Additional Informations for Clarification
        
        ### üß© 1Ô∏è‚É£ Understanding:
        
        ```bash
        printf "%s\n" "$(cat /etc/bandit_pass/bandit15)"
        ```
        
        ### Step by step:
        
        1. **`cat /etc/bandit_pass/bandit15`**
            - Reads the password (a single line of text) from that file.
            - Example output:
                
                ```
                th3Pa55word!
                ```
                
        2. **`$( ... )`**
            - This is **command substitution** ‚Äî it runs the command inside the parentheses and replaces it with its output.
            - So `$(cat /etc/bandit_pass/bandit15)` becomes the actual password string.
        3. **`printf "%s\n" "the_password_here"`**
            - `printf` is a safer version of `echo`.
            - `"%s\n"` means:
                - `%s` ‚Üí print the string.
                - `\n` ‚Üí then print a newline.
            - This guarantees that the password ends with a proper newline ‚Äî which is important because the server expects you to *press Enter* (i.e., send `\n`) after the password.
            - `echo` sometimes behaves inconsistently across systems (especially with special characters), so `printf` is more reliable.
        
        ### üîÑ 2Ô∏è‚É£ Why `<` instead of `>` in:
        
        ```bash
        openssl s_client -connect localhost:30001 -quiet < /etc/bandit_pass/bandit15
        ```
        
        This is about **redirection direction**:
        
        - `<` means **redirect file input** ‚Äî i.e., feed the contents of that file *into* the command‚Äôs standard input (stdin).
            - Think: ‚Äúread from this file.‚Äù
        - `>` means **redirect output** ‚Äî i.e., take whatever the command *prints* and send it *into a file* (overwrite it).
            - Think: ‚Äúwrite into this file.‚Äù
        
        So in this command:
        
        - We want to **send** the password file *into* the SSL connection (as if typing it).
        - That‚Äôs why we use **`<`** (input redirection).
        
        If you accidentally used `>`, you‚Äôd tell the shell:
        
        > ‚ÄúTake the output of openssl s_client and overwrite the password file with it.‚Äù
        > 
        
        ‚Ä¶which would destroy your password file üòÖ 
        
        ---
        
        ## üß† Summary
        
        | Symbol | Direction | Meaning | Example Purpose |
        | --- | --- | --- | --- |
        | `<` | into command | send file contents as input | `openssl ‚Ä¶ < password.txt` |
        | `>` | out of command | save command output to file | `echo hello > file.txt` |
        | ` | ` | command-to-command | pipe one command‚Äôs output to another |
- Level 16
    - The credentials for the next level can be retrieved by submitting the password of the current level to a port on localhost in the range 31000 to 32000. First find out which of these ports have a server listening on them. Then find out which of those speak SSL/TLS and which don‚Äôt. There is only 1 server that will give the next credentials, the others will simply send back to you whatever you send to it.
        
        ## How we determined the correct port and the password (summary of steps)
        
        1. **Discover listening ports in range 31000‚Äì32000.**
            - We used `nmap` to find which ports in that range had services listening. `nmap -p 31000-32000` showed five open ports: `31046 31518 31691 31790 31960`.
        2. **Probe each port to find which speak TLS vs plain TCP.**
            - `openssl s_client` handshake tests indicated `31518` and `31790` are TLS services (they returned certificate info), while the others behaved like plain TCP echo services.
        3. **Send the current password to each candidate over the correct protocol.**
            - For TLS ports we used `openssl s_client` and piped the password into it; for plain TCP we would use `nc`.
            - Each echo server simply returned the same password back. The correct server returned a **different** single-line response ‚Äî that different string is the **next-level password**.
        4. **Identify the correct response.**
            - We inspected the returned outputs; the one that differed from what we sent (and looked like a Bandit password/token) was taken as the bandit17 password.
        
        # THE ACTUAL STEPS AND COMMANDS:
        
        ### 1.) the actual Nmap scan
        
        PORT STATE SERVICE 
        
        31046/tcp open unknown
        
        31518/tcp open unknown 
        
        31691/tcp open unknown 
        
        31790/tcp open unknown 
        
        31960/tcp open unknown
        
        ### 2.)  **Probe each port to find which speak TLS vs plain TCP**
        
        TLS handshake probe (fast, non-blocking)
        
        ```bash
        timeout 2 bash -c 'echo | openssl s_client -connect 127.0.0.1:PORT 2>&1' | sed -n '1,6p'
        ```
        
        - If output contains `CONNECTED` or `----BEGIN CERTIFICATE-----` it‚Äôs TLS.
        
        ‚Üí The output from this command showed two ports running TSL certificates. The responses were as such: 
        
        bandit16@bandit:~$ timeout 2 bash -c 'echo | openssl s_client -connect 127.0.0.1**:31518** 2>&1' | sed -n '1,6p' Can't use SSL_get_servername depth=0 CN = SnakeOil verify error:num=18:self-signed certificate verify return:1 depth=0 CN = SnakeOil verify return:1
        
        **MEANING:** 
        
        **What your probe output means (port-by-port)**
        
        - `31518` and `31790` ‚Äî output shows a certificate (`depth=0 CN = SnakeOil`) ‚Üí **these are TLS** services.
        - `31046`, `31691`, `31960` ‚Äî output shows `CONNECTED` and `no peer certificate available` / `unexpected message` ‚Üí `openssl` connected at TCP level but the peer did not perform a TLS handshake, so these are **plain (non-TLS) TCP** services (often echo servers that speak plain text).
        
        ### 3.)  **Send the current password to each candidate over the correct protocol.**
        
        - If you prefer a single-line one-liner:
        
        ```bash
        PASS="$(cat /etc/bandit_pass/bandit16)"; for p in 31518 31790; do echo "---- $p ----"; printf "%s\n" "$PASS" | timeout 3 bash -c "openssl s_client -connect 127.0.0.1:$p -quiet 2>/dev/null" | sed -n '1,8p'; done
        ```
        
        ### What the one-liner does (line-by-line explanation)
        
        Command we ran:
        
        ```bash
        PASS="$(cat /etc/bandit_pass/bandit16)"; for p in 31518 31790; do echo "---- $p ----"; printf "%s\n" "$PASS" | timeout 3 bash -c "openssl s_client -connect 127.0.0.1:$p -quiet 2>/dev/null" | sed -n '1,8p'; done
        ```
        
        - `PASS="$(cat /etc/bandit_pass/bandit16)"`
            - **Reads the current-level password** from the file into the shell variable `PASS`.
            - Using `$(...)` captures the command output exactly (no extra newlines beyond what the file has). Storing it in a variable lets us reuse it easily.
        - `;`
            - Separator so we can run the `for` loop next on the same command line.
        - `for p in 31518 31790; do ...; done`
            - A shell loop that runs the inner block once for each port (`p`) listed. These were the two ports we detected earlier as TLS-capable.
        - `echo "---- $p ----"`
            - Prints a small header so the outputs from different ports are easy to distinguish.
        - `printf "%s\n" "$PASS"`
            - **Prints the password followed by a newline**.
            - `printf` is used instead of `echo` because it is consistent and won‚Äôt reinterpret escape sequences or change behavior with odd characters. The `\n` ensures the remote service receives a newline (like pressing Enter).
        - `|`
            - Pipes the printed password into the stdin of the next command. So the password becomes the input to `openssl s_client`.
        - `timeout 3 bash -c "openssl s_client -connect 127.0.0.1:$p -quiet 2>/dev/null"`
            - `timeout 3` ‚Äî ensures the whole `openssl` attempt will be killed after 3 seconds if it hangs (avoids you waiting forever).
            - `bash -c "..."` ‚Äî runs the quoted command string **in a shell** (we used this so `timeout` wraps the whole `openssl` invocation reliably).
            - `openssl s_client -connect 127.0.0.1:$p -quiet` ‚Äî opens an SSL/TLS connection to the local port `p`, reads from stdin (the password we piped) and sends it over the TLS channel. `quiet` suppresses most of `openssl`'s verbose handshake text so the server reply is easier to read.
            - `2>/dev/null` ‚Äî discards `openssl`'s diagnostic output (stderr), leaving only the server response on stdout (which is what we want to inspect).
        - `| sed -n '1,8p'`
            - Pipes the server response into `sed` and prints only the **first 8 lines**. This prevents huge or noisy responses from cluttering your terminal and surfaces the likely single-line password which is usually at the top.
        
        **Data flow**:
        
        `password file` ‚Üí `printf` ‚Üí pipe ‚Üí `openssl s_client` (TLS connect to server) ‚Üí server responds ‚Üí `sed` prints first lines.
        
        ### Why we used `openssl s_client` and TLS ports
        
        - Earlier probes (with `openssl s_client` and `nc`) told us port **31518** and **31790** were speaking TLS (they presented a certificate), so we needed to open an SSL/TLS connection to those ports rather than plain `nc` (which would send plaintext).
        - `openssl s_client` performs a TLS handshake and then sends whatever is on its stdin over the encrypted channel. That‚Äôs exactly what the challenge required: **submit the current password over TLS** to candidate ports and read the reply.
        
        ### TROUBLESHOOTING - ADDITIONAL NOTES:
        
        ### üß© What `sed` actually is
        
        `sed` stands for **Stream EDitor**.
        
        It reads **text input line by line**, applies editing commands (like search, replace, delete, print), and writes the result to **stdout** (your terminal or a file).
        
        It‚Äôs called a *stream* editor because it processes text as it streams through a pipe ‚Äî not by loading an entire file into memory.
        
        ---
        
        ### ‚öôÔ∏è In ourcommand
        
        We had:
        
        ```bash
        | sed -n '1,8p'
        ```
        
        Let‚Äôs break it down:
        
        - `|` ‚Äî sends the output of the previous command (the TLS server‚Äôs response) **into** `sed`.
        - `n` ‚Äî tells `sed` **not** to print every line automatically**.**
            
            Normally `sed` prints all lines unless told otherwise.
            
        - `'1,8p'` ‚Äî means: **for lines 1 through 8, print them.**
            - `1,8` is a **range of line numbers**.
            - `p` means **print**.
        
        So this whole thing means:
        
        > ‚ÄúRead the incoming text, and only print the first 8 lines ‚Äî stay silent about the rest.‚Äù
        > 
        
        ---
        
        ### üß† Why we use it here
        
        `openssl s_client` often dumps *a lot* of text (certificates, handshake info, etc.).
        
        You only need to see the top few lines of the **server‚Äôs response** (where the password usually appears).
        
        So `sed -n '1,8p'` trims the output for clarity.
        
- Level 17
    - There are 2 files in the homedirectory: passwords.old and passwords.new. The password for the next level is in passwords.new and is the only line that has been changed between passwords.old and passwords.new
        
        You have:
        
        - `passwords.old`
        - `passwords.new`
        
        The password you need is **the only line that differs between the two files**.
        
        So we simply need a tool that compares files line‚Äëby‚Äëline.
        
        ---
        
        # ‚úÖ The correct command
        
        Use `diff`:
        
        ```bash
        diff passwords.old passwords.new
        ```
        
        This will show output like:
        
        ```
        < oldpasswordline
        > newpasswordline
        ```
        
        The line with the **greater-than sign (`>`)** is the one from `passwords.new`.
        
        **That is the password for bandit18.**
        
        ---
        
        # üî• If you want a cleaner output
        
        To show only the new line:
        
        ```bash
        diff passwords.old passwords.new | grep ">"
        ```
        
        Or even cleaner:
        
        ```bash
        diff --new-line-format="%L" --old-line-format="" --unchanged-line-format="" passwords.old passwords.new
        ```
        
        This prints **only** the changed new line.
        
        ---
        
        # üí° Summary of what‚Äôs happening
        
        - The challenge states exactly one line changed.
        - `diff` compares each line in both files.
        - The changed line in `passwords.new` is the new password.
- Level 18
    - The password for the next level is stored in a file readme in the homedirectory. Unfortunately, someone has modified .bashrc to log you out when you log in with SSH.
        - Normally you log in via SSH and get a shell.
        - But here, `.bashrc` in your home directory is set up to **log you out immediately**.
        - So you **cannot interactively log in** in the usual way.
        
        This is a classic ‚Äúdon‚Äôt execute `.bashrc`‚Äù problem. The trick is to **bypass the automatic logout**.
        
        ---
        
        ## ‚úÖ Ways to bypass `.bashrc`
        
        ### 1. Run a command directly via SSH
        
        Instead of opening a shell, you can run a command directly:
        
        ```bash
        ssh bandit18@bandit.labs.overthewire.org -p 2220 cat readme
        ```
        
        - This logs in, executes `cat readme` **without running `.bashrc` interactively**, and prints the password.
        
        > Why this works: When you pass a command to SSH, it doesn‚Äôt start an interactive shell. .bashrc is only sourced for interactive shells.
        > 
        
        ---
        
        ### 2. Use `scp` to copy the file locally
        
        You can also copy the file without triggering `.bashrc`:
        
        ```bash
        scp -P 2220 bandit18@bandit.labs.overthewire.org:readme .
        cat readme
        ```
        
        - This copies the file to your local machine and then you can read it safely.
        
        ---
        
        ### 3. Temporary safe shell via `ssh -t`
        
        If you need a shell for more exploration, you can bypass `.bashrc` like this:
        
        ```bash
        ssh bandit18@bandit.labs.overthewire.org -p 2220 'bash --noprofile --norc'
        ```
        
        - `-norc` prevents `.bashrc` from running.
        - Then you can explore safely.
        
        ---
        
        ### ‚úÖ Summary
        
        - `.bashrc` logs you out to trap you.
        - **Solution:** don‚Äôt start an interactive shell. Run the command directly: `cat readme` or `scp` it out.
        - The **readme** file contains the **password for bandit19**.
- Level 19
    - To gain access to the next level, you should use the setuid binary in the homedirectory. Execute it without arguments to find out how to use it. The password for this level can be found in the usual place (/etc/bandit_pass), after you have used the setuid binary.
        
        ### You have a **setuid binary** in the home directory
        
        This binary runs **as user bandit20**, even though you are logged in as **bandit19**.
        
        So you must use it to read the file:
        
        ```
        /etc/bandit_pass/bandit20
        ```
        
        which you normally **cannot** read.
        
        ---
        
        ## ‚úÖ Step 1 ‚Äî See what the binary does
        
        In your home directory, check the files:
        
        ```bash
        ls -l
        ```
        
        You‚Äôll see :
        
        ```
        total 16
        -rwsr-x--- 1 bandit20 bandit19 14884 Oct 14 09:26 bandit20-do
        ```
        
        The important part:
        
        - `s` ‚áí **setuid bit**, meaning:
            - *When you run it, it runs with bandit20‚Äôs permissions.*
        
        Now run it with no arguments:
        
        ```bash
        ./bandit20-do
        ```
        
        It will print something like:
        
        ```
        Run this command with one argument: <command to execute>
        ```
        
        (Usually the help text says you must pass it a command to run as bandit20.)
        
        ---
        
        ## ‚úÖ Step 2 ‚Äî Use the setuid binary to read the password
        
        The trick is to give it a command that reads the password file.
        
        Example:
        
        ```bash
        ./bandit20-do cat /etc/bandit_pass/bandit20
        ```
        
        Because the binary runs **as bandit20**, the `cat` command has permission to read the file. This switches your identity to bandit20.
        
- Level 20
    - There is a setuid binary in the homedirectory that does the following: it makes a connection to localhost on the port you specify as a commandline argument. It then reads a line of text from the connection and compares it to the password in the previous level (bandit20). If the password is correct, it will transmit the password for the next level (bandit21).
        -
